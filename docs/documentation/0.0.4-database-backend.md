---
title: Database Backend Implementation
version: 0.0.4
date: 2025-11-22
status: draft
---

# Database Backend Implementation

> **Purpose:** Full CMS architecture with self-hosted Docker deployment
> **Cost:** $0 (self-hosted) or $5/mo VPS

---

## Architecture

```
┌─────────────────┐
│  React Frontend │
│  (Static Vite)  │
└────────┬────────┘
         │
         │ REST API
         ▼
┌─────────────────┐
│  Node.js API    │
│  (Express)      │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│  PostgreSQL     │
│  (Database)     │
└─────────────────┘
```

All running in Docker containers.

---

## Database Schema

```sql
-- documents table
CREATE TABLE documents (
  id SERIAL PRIMARY KEY,
  slug VARCHAR(255) UNIQUE NOT NULL,
  version VARCHAR(20) NOT NULL,
  title VARCHAR(255) NOT NULL,
  subtitle VARCHAR(255),
  content TEXT NOT NULL,
  frontmatter JSONB,
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);

-- indexes for performance
CREATE INDEX idx_version ON documents(version);
CREATE INDEX idx_slug ON documents(slug);
CREATE INDEX idx_created_at ON documents(created_at DESC);

-- full-text search
CREATE INDEX idx_content_search ON documents USING GIN(to_tsvector('english', content));
CREATE INDEX idx_title_search ON documents USING GIN(to_tsvector('english', title));
```

---

## Docker Compose Setup

**File:** `docker-compose.yml`

```yaml
version: '3.8'

services:
  # PostgreSQL Database
  db:
    image: postgres:16-alpine
    restart: always
    environment:
      POSTGRES_DB: wiki
      POSTGRES_USER: wiki
      POSTGRES_PASSWORD: ${DB_PASSWORD}
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./db/init.sql:/docker-entrypoint-initdb.d/init.sql
    ports:
      - "5432:5432"
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U wiki"]
      interval: 10s
      timeout: 5s
      retries: 5

  # Node.js API
  api:
    build: ./api
    restart: always
    depends_on:
      db:
        condition: service_healthy
    environment:
      NODE_ENV: production
      DATABASE_URL: postgresql://wiki:${DB_PASSWORD}@db:5432/wiki
      PORT: 3000
      JWT_SECRET: ${JWT_SECRET}
    ports:
      - "3000:3000"
    volumes:
      - ./api:/app
      - /app/node_modules

  # Nginx (Frontend + Reverse Proxy)
  nginx:
    image: nginx:alpine
    restart: always
    depends_on:
      - api
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./dist:/usr/share/nginx/html
      - ./nginx.conf:/etc/nginx/nginx.conf
      - ./ssl:/etc/nginx/ssl

volumes:
  postgres_data:
```

---

## API Implementation

**File:** `api/package.json`

```json
{
  "name": "wiki-api",
  "version": "1.0.0",
  "type": "module",
  "scripts": {
    "start": "node server.js",
    "dev": "nodemon server.js"
  },
  "dependencies": {
    "express": "^4.18.2",
    "pg": "^8.11.3",
    "cors": "^2.8.5",
    "dotenv": "^16.3.1"
  }
}
```

**File:** `api/server.js`

```javascript
import express from 'express'
import cors from 'cors'
import pg from 'pg'
import dotenv from 'dotenv'

dotenv.config()

const app = express()
const { Pool } = pg

const pool = new Pool({
  connectionString: process.env.DATABASE_URL
})

app.use(cors())
app.use(express.json())

// GET all documents (for navigation)
app.get('/api/documents', async (req, res) => {
  try {
    const result = await pool.query(
      'SELECT id, slug, version, title, subtitle, frontmatter, created_at FROM documents ORDER BY version'
    )
    res.json(result.rows)
  } catch (error) {
    console.error(error)
    res.status(500).json({ error: 'Database error' })
  }
})

// GET single document by slug
app.get('/api/documents/:slug', async (req, res) => {
  try {
    const { slug } = req.params
    const result = await pool.query(
      'SELECT * FROM documents WHERE slug = $1',
      [slug]
    )

    if (result.rows.length === 0) {
      return res.status(404).json({ error: 'Document not found' })
    }

    res.json(result.rows[0])
  } catch (error) {
    console.error(error)
    res.status(500).json({ error: 'Database error' })
  }
})

// POST create document
app.post('/api/documents', async (req, res) => {
  try {
    const { slug, version, title, subtitle, content, frontmatter } = req.body

    const result = await pool.query(
      `INSERT INTO documents (slug, version, title, subtitle, content, frontmatter)
       VALUES ($1, $2, $3, $4, $5, $6)
       RETURNING *`,
      [slug, version, title, subtitle, content, JSON.stringify(frontmatter)]
    )

    res.status(201).json(result.rows[0])
  } catch (error) {
    console.error(error)
    if (error.code === '23505') {
      return res.status(409).json({ error: 'Document already exists' })
    }
    res.status(500).json({ error: 'Database error' })
  }
})

// PUT update document
app.put('/api/documents/:slug', async (req, res) => {
  try {
    const { slug } = req.params
    const { title, subtitle, content, frontmatter } = req.body

    const result = await pool.query(
      `UPDATE documents
       SET title = $1, subtitle = $2, content = $3, frontmatter = $4, updated_at = NOW()
       WHERE slug = $5
       RETURNING *`,
      [title, subtitle, content, JSON.stringify(frontmatter), slug]
    )

    if (result.rows.length === 0) {
      return res.status(404).json({ error: 'Document not found' })
    }

    res.json(result.rows[0])
  } catch (error) {
    console.error(error)
    res.status(500).json({ error: 'Database error' })
  }
})

// DELETE document
app.delete('/api/documents/:slug', async (req, res) => {
  try {
    const { slug } = req.params
    const result = await pool.query(
      'DELETE FROM documents WHERE slug = $1 RETURNING slug',
      [slug]
    )

    if (result.rows.length === 0) {
      return res.status(404).json({ error: 'Document not found' })
    }

    res.json({ message: 'Document deleted', slug: result.rows[0].slug })
  } catch (error) {
    console.error(error)
    res.status(500).json({ error: 'Database error' })
  }
})

// Search documents
app.get('/api/search', async (req, res) => {
  try {
    const { q } = req.query

    if (!q) {
      return res.status(400).json({ error: 'Query parameter required' })
    }

    const result = await pool.query(
      `SELECT id, slug, version, title, subtitle,
              ts_rank(to_tsvector('english', title || ' ' || content), plainto_tsquery('english', $1)) AS rank
       FROM documents
       WHERE to_tsvector('english', title || ' ' || content) @@ plainto_tsquery('english', $1)
       ORDER BY rank DESC
       LIMIT 20`,
      [q]
    )

    res.json(result.rows)
  } catch (error) {
    console.error(error)
    res.status(500).json({ error: 'Database error' })
  }
})

const PORT = process.env.PORT || 3000
app.listen(PORT, () => {
  console.log(`API server running on port ${PORT}`)
})
```

**File:** `api/Dockerfile`

```dockerfile
FROM node:20-alpine

WORKDIR /app

COPY package*.json ./
RUN npm install --production

COPY . .

EXPOSE 3000

CMD ["node", "server.js"]
```

---

## Database Init Script

**File:** `db/init.sql`

```sql
-- Create documents table
CREATE TABLE IF NOT EXISTS documents (
  id SERIAL PRIMARY KEY,
  slug VARCHAR(255) UNIQUE NOT NULL,
  version VARCHAR(20) NOT NULL,
  title VARCHAR(255) NOT NULL,
  subtitle VARCHAR(255),
  content TEXT NOT NULL,
  frontmatter JSONB,
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);

-- Indexes
CREATE INDEX IF NOT EXISTS idx_version ON documents(version);
CREATE INDEX IF NOT EXISTS idx_slug ON documents(slug);
CREATE INDEX IF NOT EXISTS idx_created_at ON documents(created_at DESC);

-- Full-text search indexes
CREATE INDEX IF NOT EXISTS idx_content_search ON documents USING GIN(to_tsvector('english', content));
CREATE INDEX IF NOT EXISTS idx_title_search ON documents USING GIN(to_tsvector('english', title));
```

---

## Frontend API Integration

**File:** `src/utils/api.js`

```javascript
const API_BASE = import.meta.env.VITE_API_URL || 'http://localhost:3000/api'

export async function fetchDocuments() {
  const response = await fetch(`${API_BASE}/documents`)
  if (!response.ok) throw new Error('Failed to fetch documents')
  return response.json()
}

export async function fetchDocument(slug) {
  const response = await fetch(`${API_BASE}/documents/${slug}`)
  if (!response.ok) throw new Error('Failed to fetch document')
  return response.json()
}

export async function createDocument(data) {
  const response = await fetch(`${API_BASE}/documents`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(data)
  })
  if (!response.ok) throw new Error('Failed to create document')
  return response.json()
}

export async function updateDocument(slug, data) {
  const response = await fetch(`${API_BASE}/documents/${slug}`, {
    method: 'PUT',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(data)
  })
  if (!response.ok) throw new Error('Failed to update document')
  return response.json()
}

export async function deleteDocument(slug) {
  const response = await fetch(`${API_BASE}/documents/${slug}`, {
    method: 'DELETE'
  })
  if (!response.ok) throw new Error('Failed to delete document')
  return response.json()
}

export async function searchDocuments(query) {
  const response = await fetch(`${API_BASE}/search?q=${encodeURIComponent(query)}`)
  if (!response.ok) throw new Error('Failed to search')
  return response.json()
}
```

**Update:** `src/utils/loadDocs.js`

```javascript
import { fetchDocuments } from './api.js'

export async function loadDocsFromAPI() {
  const documents = await fetchDocuments()

  // Build navigation tree
  const sections = {}

  documents.forEach(doc => {
    const majorVersion = doc.version.split('.')[0]
    if (!sections[majorVersion]) {
      sections[majorVersion] = {
        title: getSectionTitle(majorVersion),
        items: []
      }
    }
    sections[majorVersion].items.push({
      slug: doc.slug,
      title: doc.title,
      version: doc.version
    })
  })

  return Object.entries(sections).map(([key, section]) => ({
    ...section,
    version: key
  }))
}

function getSectionTitle(version) {
  const titles = {
    '0': 'Meta',
    '1': 'Foundation',
    '2': 'Design System',
    '3': 'Components',
    '4': 'Pages',
    '5': 'Workshop',
    '6': 'Research',
    '7': 'Operations',
    '8': 'Decisions',
    '9': 'Future'
  }
  return titles[version] || `Section ${version}`
}
```

---

## Migration Script

**File:** `scripts/migrate-to-db.js`

```javascript
import fs from 'fs'
import path from 'path'
import pg from 'pg'
import dotenv from 'dotenv'

dotenv.config()

const { Pool } = pg
const pool = new Pool({
  connectionString: process.env.DATABASE_URL
})

const DOCS_DIR = path.join(process.cwd(), 'src/data/documentation')

async function migrateDocuments() {
  const files = fs.readdirSync(DOCS_DIR).filter(f => f.endsWith('.md'))

  console.log(`Migrating ${files.length} documents...`)

  for (const file of files) {
    const content = fs.readFileSync(path.join(DOCS_DIR, file), 'utf-8')

    // Parse frontmatter
    const frontmatterMatch = content.match(/^---\n([\s\S]*?)\n---\n/)
    const frontmatter = {}
    const body = frontmatterMatch ? content.slice(frontmatterMatch[0].length) : content

    if (frontmatterMatch) {
      frontmatterMatch[1].split('\n').forEach(line => {
        const [key, ...values] = line.split(':')
        if (key && values.length) {
          frontmatter[key.trim()] = values.join(':').trim()
        }
      })
    }

    // Extract version from filename (M.m.p-slug.md)
    const match = file.match(/^(\d+\.\d+\.\d+)-(.+)\.md$/)
    if (!match) {
      console.warn(`Skipping invalid filename: ${file}`)
      continue
    }

    const [, version, slug] = match

    try {
      await pool.query(
        `INSERT INTO documents (slug, version, title, subtitle, content, frontmatter)
         VALUES ($1, $2, $3, $4, $5, $6)
         ON CONFLICT (slug) DO UPDATE
         SET content = EXCLUDED.content, frontmatter = EXCLUDED.frontmatter, updated_at = NOW()`,
        [
          slug,
          version,
          frontmatter.title || slug,
          frontmatter.subtitle || null,
          body,
          JSON.stringify(frontmatter)
        ]
      )
      console.log(`✓ Migrated: ${file}`)
    } catch (error) {
      console.error(`✗ Failed to migrate ${file}:`, error.message)
    }
  }

  await pool.end()
  console.log('Migration complete!')
}

migrateDocuments()
```

Run with: `node scripts/migrate-to-db.js`

---

## Deployment

### Local Development

```bash
# 1. Create .env file
cat > .env <<EOF
DB_PASSWORD=your_secure_password
JWT_SECRET=your_secret_key
EOF

# 2. Start services
docker-compose up -d

# 3. Run migration
node scripts/migrate-to-db.js

# 4. Frontend dev server
yarn dev
```

Access:
- Frontend: `http://localhost:5177`
- API: `http://localhost:3000`
- Database: `localhost:5432`

### Self-Hosted Production

**Requirements:**
- Any VPS ($5/mo): DigitalOcean, Hetzner, Linode
- Docker installed
- Domain name (optional)

**Deploy:**

```bash
# 1. SSH to server
ssh root@your-server.com

# 2. Clone repo
git clone https://github.com/your-user/wiki.git
cd wiki

# 3. Build frontend
yarn install
yarn build

# 4. Start Docker services
docker-compose up -d

# 5. Run migration
docker-compose exec api node /app/migrate-to-db.js

# 6. (Optional) Setup SSL with Let's Encrypt
docker run --rm -v ./ssl:/etc/letsencrypt \
  certbot/certbot certonly --standalone \
  -d your-domain.com
```

Done! Wiki running at `http://your-server-ip`

---

## Cost Comparison

| Option | Monthly Cost | Notes |
|--------|--------------|-------|
| Self-hosted (VPS) | $5 | Full control, unlimited |
| Vercel + Supabase | $25 | Easier, auto-scaling |
| AWS/GCP | $20-50 | Complex, enterprise |

Self-hosting wins for personal/small team use.

---

## Next Steps

1. Implement authentication (JWT)
2. Add permissions system
3. Version history (track edits)
4. Real-time collaboration (WebSockets)
5. Automated backups

---

*Self-hosted database backend for full CMS capabilities at minimal cost.*
